=============================================
Debugging（调试） and Profiling（性能分析）
=============================================

调试
===============
软件中的“bug”和“debugging”这两个词被普遍认为是由Admiral Grace Hopper提出的。她是一个真正的
传奇人物，编写了有史以来的第一个编译器。20世纪40年代，当她在哈佛大学为美国海军开发的一台计算机工
作时，她的同事发现一只飞蛾（一种真实的昆虫）卡在一个继电器中，使计算机崩溃。在解决这个问题时，她
说，他们正在debugging系统。从此在计算机中“bug”被用来表示程序的异常、错误行为，“debugging”被
用来表示解决程序异常、错误行为的过程，也被称为调试程序。

编程界有一条金科玉律，“代码不能完全按照您的想法运行，它只能完全按照您的写法运行”。让您的写法符合
想法是很困难的，在纠正您的写法的过程中最有效的手段就是代码调试。

调试可以定义为在代码库中找到问题的根源并加以修复的过程。

调试分类
----------
调试是软件开发过程中的核心部分，作为软件开发人员在开发软件的过程中需要花费大量的时间来调试我们的
代码，所以我们需要掌握常用的调试方法，让调试的过程更加方便快捷，缩短研发周期。从调试的代码状态来
看分为静态分析和动态调试，从调试的层级来看分为源码级调试和汇编级调试。

静态分析
**********
静态分析是指 **不需要实际运行程序**，甚至不需要编译程序，而是在程序源代码或指令的层级进行一系列
分析甚至“枚举”，预测程序的可能执行情况，寻找潜在的问题。某种程度上来说，对于存在问题的程序，程序
员直接阅读代码或汇编指令并分析问题，也可以被视为一种静态分析。

静态分析也有着广泛的应用，许多静态分析工具在无需编译或运行程序的情况下便可分析程序的潜在问题，这
可以有效节约程序运行的时间，同时静态分析可以尽可能地枚举程序的可能执行路径，有助于发现实际运行程
序时不会出现或非常罕见的问题。

动态调试
*********
与静态分析相对应的是动态调试，指的是在 **程序运行的过程中** 对程序运行施加干预进行观测，定位和
解决问题的过程。一种常见的动态调试方法是断点，通过插入断点使得程序在特定位置暂停运行，让动态调试
器可以对程序的状态进行进一步的观测。

相较于静态分析，动态调试可以真实地反映程序运行的实际情况，包括各种数据的实际值、程序的实际执行路
径等。在某些场景下，使用动态调试寻找程序的问题或理解程序的行为，比直接阅读程序源码要简单许多，例
如使用动态调试器单步运行程序，在每一步运行的前后观察程序的相关状态，可以非常直观地找到导致问题的
程序指令或代码。

源码级调试和汇编级调试
*****************************
从开发者角度来看，在调试程序时往往希望程序执行到某个断点，然后直接检查程序中变量或复杂对象的值，
从而定位程序出现的问题。在程序的哪个位置设置断点，程序运行时触发断点后，应该检查哪个变量或对象的
值，这样都依赖开发者本身对程序的了解。这种开发者直接站在源代码的层级，使用源代码级的概念（代码行、
变量、对象等）进行调试的过程称为 **源码级调试**。

从程序运行角度来看，CPU只能运行二进制形式的机器指令，不论是编译型还是解释型高级语言，最终在CPU上
执行时都是一条一条的机器指令，观察机器指令运行时只能看到寄存器、内存地址等，并不能观察到开发者熟
悉的变量和对象，因为在机器指令的层面并没有变量和对象的概念，只有寄存器和内存。这种只使用机器执行
过程中直接可见的概念(指令、 寄存器、内存)进行调试的过程称为 **汇编级调试/机器级调试**。

从上述的分析中可以看到源码级调试对开发者调试代码更友好，但是动态调试代码时面向的却是正在执行的程
序，即一堆二进制形式的机器指令，应该使用汇编级调试。动态调试时源码级调试和汇编级调试存在鸿沟，因
为从源代码到可执行程序的编译或解释过程中，许多信息都丢失了，因为这些信息对于程序的最终执行并无任
何帮助。从程序执行的角度来说，CPU不需要理解某条指令对应源代码中的哪个文件的哪一行，也不需要理解
某个寄存器在某一时刻存储的是哪个变量的值。但是，这些信息的丢失，就给调试带来了较大的困难，因为高
级语言翻译成汇编指令的方式非常多样，并且存在各种复杂的细节，从而使得汇编级调试并不直观，往往需要
远多于源码级调试的时间精力才有可能定位和理解程序存在的问题。

为了在动态调试时使用源码级调试，就需要在程序可执行文件中加入一系列的额外信息，来弥补编译/解释过程
中损失的信息，让动态调试器可以把指令地址、寄存器、内存地址“还原”为源代码级的概念如源代码行、变量、
对象等等。但是，嵌入这些信息会使得程序可执行文件的体积增大，所以如果不是在编译时使用特定的选项，
程序往往是没有这些额外信息的。以Linux下最常见的可执行文件格式ELF为例，若要支持源码级调试，需要
ELF文件存在符号表和专门的调试信息。其中符号表可以用于将一些内存地址还原回函数或全局变量等，除了
调试之外，还有许多其他用途，而调试信息则是专门为了将机器级概念还原到源代码级存在的。如果一个ELF
文件只有符号表，没有调试信息，那么绝大多数源码级调试功能也都是不可用的，但是也可以支持一定程度的
源码级调试，例如在函数的入口打断点，检查全局变量的值等。

调试方法
---------

静态分析
*********
有些问题是不需要执行代码就能发现的。例如，仔细观察一段代码，就能发现某个循环变量覆盖了某个已经存
在的变量或函数名；或是有个变量在被读取之前并没有被定义。这种情况下静态分析工具就可以帮开发者找到
问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理，发现代
码的问题等。

大多数的编辑器和IDE都支持在编辑界面就可以显示静态分析工具的分析结果、高亮有警告和错误的位置。这
个过程通常称为code linting 。风格检查或安全检查的结果同样也可以进行相应的显示。在vim中，有ALE或Syntastic可以帮助开发者做同样的事情。

打印调试
*********
Brian Kernighan在Unix新手入门中曾说，"最有效的debug工具就是细致的分析，配合恰当位置的打印语句"。

在调试代码时首选的方式就是在可能出现问题或者已经发现问题的地方添加打印语句，打印变量或表达式的值。
不断重复此过程直到获取了足够的信息并定位到了使程序出现问题的根本原因。在C/C++中可以使用printf语
句打印信息，如下：

.. code-block:: c++
  
  #include <stdio.h>
  #include <iostream>

  int main(int argc, char* argv[]) {
    int a;
    ...
    printf("%d\n", a);
    // c++可使用
    // std::cout << a << std::endl;
    ...

    return 0;
  }

日志调试
*********
与打印语句功能类似的调试方法是日志调试，日志相比于普通的打印语句有如下优势：

- 可以将打印信息写入文件，持久化存储并通过网络发送到其他设备；
- 日志可以支持程序问题的严重等级（常见的有INFO、WARN、ERROR、FATAL等），可以通过等级来过滤打印信息。

C/C++语言中没有自带的日志库用于日志调试，其他高级语言可查看日志库支持信息。为了在C/C++开发过程
中使用日志调试，通过会在开发过程为项目自定义日志模块或直接使用第三方日志库。

第三方日志库
~~~~~~~~~~~~~
针对C/C++项目常用的第三方日志库有GLog、spdlog等，在开发过程中如需要可根据日志库的要求引入到项
目中，具体请参见日志库的主页或代码仓库。

调试工具
*********
当通过打印已经不能满足调试需求时，开发者应该使用调试器。调试器是一种可以允许我们和正在执行的程序
进行交互的程序，它可以做到：

- 当到达某一行时将程序暂停；
- 一次一条指令地逐步执行程序；
- 程序崩溃后查看变量的值；
- 满足特定条件时暂停程序；
- 其他高级功能。

很多编程语言都有自己的调试器，C/C++项目最常用的调试器是GDB，具体使用方法请参见同级目录下的gdb
文档。

.. 性能分析
